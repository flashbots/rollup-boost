use reth::{
    chainspec::{EthChainSpec as _, Hardforks},
    network::{
        types::BasicNetworkPrimitives, NetworkConfig, NetworkHandle, NetworkManager,
        NetworkPrimitives,
    },
};
use reth_eth_wire::{
    capability::SharedCapabilities, multiplex::ProtocolConnection, protocol::Protocol,
};
/// OpNetworkBuilder impls NetworkBuilder -> NetworkHandle impls NetworkProtocols
///
/// NetworkConfig has `extra_protocols`
///
// #![cfg_attr(not(any(test, feature = "test")), warn(unused_crate_dependencies))]
//
// pub mod args;
// pub mod node;
//
// #[cfg(any(feature = "test", test))]
// pub mod test_utils;
use reth_network::protocol::{ConnectionHandler, IntoRlpxSubProtocol, ProtocolHandler};
use reth_node_api::{PrimitivesTy, TxTy};
use reth_node_builder::{
    components::{
        BasicPayloadServiceBuilder, ComponentsBuilder, ConsensusBuilder, ExecutorBuilder,
        NetworkBuilder, PayloadBuilderBuilder, PoolBuilder, PoolBuilderConfigOverrides,
        TxPoolBuilder,
    },
    node::{FullNodeTypes, NodeTypes},
    rpc::{
        EngineApiBuilder, EngineValidatorAddOn, EngineValidatorBuilder, EthApiBuilder, Identity,
        RethRpcAddOns, RethRpcMiddleware, RethRpcServerHandles, RpcAddOns, RpcContext, RpcHandle,
    },
    BuilderContext, DebugNode, Node, NodeAdapter, NodeComponentsBuilder,
};
use reth_provider::{
    BlockReaderIdExt, ChainSpecProvider, ExecutionOutcome, ProviderError, StateProvider,
    StateProviderFactory,
};
use reth_transaction_pool::{
    blobstore::DiskFileBlobStore, EthPoolTransaction, PeerId, PoolPooledTx, PoolTransaction,
    TransactionPool, TransactionValidationTaskExecutor,
};
use tokio::sync::oneshot;
use tracing::info;

#[derive(Clone, Debug, Default)]
pub struct FlashblocksProtocolHandler;

#[derive(Clone, Debug, Default)]
pub struct FlashblocksConnectionHandler;

/// The connection handler for the custom RLPx protocol.
pub struct FlashblocksConnection {
    conn: ProtocolConnection,
    initial_ping: Option<FlashblocksProtoMessage>,
    commands: UnboundedReceiverStream<FlashblocksCommand>,
    pending_pong: Option<oneshot::Sender<String>>,
}

impl ConnectionHandler for FlashblocksConnectionHandler {
    type Connection;

    fn protocol(&self) -> Protocol {
        todo!()
    }

    fn on_unsupported_by_peer(
        self,
        supported: &SharedCapabilities,
        direction: reth_network::Direction,
        peer_id: PeerId,
    ) -> reth_network::protocol::OnNotSupported {
        todo!()
    }

    fn into_connection(
        self,
        direction: reth_network::Direction,
        peer_id: PeerId,
        conn: ProtocolConnection,
    ) -> Self::Connection {
        todo!()
    }
}

impl ProtocolHandler for FlashblocksProtocolHandler {
    type ConnectionHandler = FlashblocksConnectionHandler;

    fn on_incoming(&self, socket_addr: std::net::SocketAddr) -> Option<Self::ConnectionHandler> {
        todo!()
    }

    fn on_outgoing(
        &self,
        socket_addr: std::net::SocketAddr,
        peer_id: PeerId,
    ) -> Option<Self::ConnectionHandler> {
        todo!()
    }
}

#[derive(Clone, Debug, Default)]
pub struct FlashblocksNetworkBuilder {
    /// Disable transaction pool gossip
    pub disable_txpool_gossip: bool,
    /// Disable discovery v4
    pub disable_discovery_v4: bool,
}

impl FlashblocksNetworkBuilder {
    /// Returns the [`NetworkConfig`] that contains the settings to launch the p2p network.
    ///
    /// This applies the configured [`OpNetworkBuilder`] settings.
    pub fn network_config<Node, NetworkP>(
        &self,
        ctx: &BuilderContext<Node>,
    ) -> eyre::Result<NetworkConfig<Node::Provider, NetworkP>>
    where
        Node: FullNodeTypes<Types: NodeTypes<ChainSpec: Hardforks>>,
        NetworkP: NetworkPrimitives,
    {
        let Self {
            disable_txpool_gossip,
            disable_discovery_v4,
            ..
        } = self.clone();
        let args = &ctx.config().network;
        let network_builder = ctx
            .network_config_builder()?
            // apply discovery settings
            .apply(|mut builder| {
                let rlpx_socket = (args.addr, args.port).into();
                if disable_discovery_v4 || args.discovery.disable_discovery {
                    builder = builder.disable_discv4_discovery();
                }
                if !args.discovery.disable_discovery {
                    builder = builder.discovery_v5(
                        args.discovery.discovery_v5_builder(
                            rlpx_socket,
                            ctx.config()
                                .network
                                .resolved_bootnodes()
                                .or_else(|| ctx.chain_spec().bootnodes())
                                .unwrap_or_default(),
                        ),
                    );
                }

                builder
            });

        let mut network_config = ctx.build_network_config(network_builder);

        // When `sequencer_endpoint` is configured, the node will forward all transactions to a
        // Sequencer node for execution and inclusion on L1, and disable its own txpool
        // gossip to prevent other parties in the network from learning about them.
        network_config.tx_gossip_disabled = disable_txpool_gossip;

        Ok(network_config)
    }
}

impl<Node, Pool> NetworkBuilder<Node, Pool> for FlashblocksNetworkBuilder
where
    Node: FullNodeTypes<Types: NodeTypes<ChainSpec: Hardforks>>,
    Pool: TransactionPool<Transaction: PoolTransaction<Consensus = TxTy<Node::Types>>>
        + Unpin
        + 'static,
{
    type Network =
        NetworkHandle<BasicNetworkPrimitives<PrimitivesTy<Node::Types>, PoolPooledTx<Pool>>>;

    async fn build_network(
        self,
        ctx: &BuilderContext<Node>,
        pool: Pool,
    ) -> eyre::Result<Self::Network> {
        let network_config = self.network_config(ctx)?;
        let network = NetworkManager::builder(network_config).await?;
        let handle = ctx.start_network(network, pool);
        // info!(target: "reth::cli", enode=%handle.local_node_record(), "P2P networking initialized");

        Ok(handle)
    }
}
